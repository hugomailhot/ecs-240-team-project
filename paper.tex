%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf} 

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document



% The following packages can be found on http:\\www.ctan.org
%\usepackage{graphics} % for pdf, bitmapped graphics files
%\usepackage{epsfig} % for postscript graphics files
%\usepackage{mathptmx} % assumes new font selection scheme installed
%\usepackage{times} % assumes new font selection scheme installed
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb}  % assumes amsmath package installed
\usepackage{xcolor}

\title{\LARGE \bf
A Formal Description of Bitcoin's Script Language
}

\author{ \parbox{4 in}{
                        \centering Domenic Cianfichi, Hugo Mailhot and Joseph McGee
                        Department of Computer Science\\
                        University of California, Davis\\
                        1 Shields Ave, Davis, CA 95616, USA
                      }
}


\begin{document}



\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

Bitcoin transactions are validated using a specialized language called Script. Despite the critical role it plays in the Bitcoin network, so far no formal description of the language has been developed to allow reasoning about the expressive power of the language. The recent years have shown that a lack of understanding of Script made it possible to create valid programs with undesirable behavior. Furthermore, the Bitcoin community acknowledges that standard transaction script formats, and maybe Script itself, might be changed in the future. In a first step to allow rigorous reasoning about Script's expressivity and limitations, we present a formal description of the language, along with example analyses that illustrate the usefulness of such a description.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

Script is what Bitcoin uses to encode transactions over the network. It is purposefully restricted, and most notably lacks a mechanism for looping and guarantees termination. To properly learn the language and understand its semantics, one must read through the catalog of \textit{opcodes} (hex values used as operators) and analyze its C++ reference implementation.

As a postfix language written in sequences of bytes, Script is not an easy language to pick up and understand. It is even harder to assess the effect that proposed modifications to the language might have on the guarantees that it must provide. In the past, Script has been progressively restricted in response to discovered vulnerabilities in the language. The restrictions eliminated the vulnerabilities, at the cost of reducing the expressiveness of the language. It is not clear that all of the restrictions added were necessary to produce the desired end of securing the language. A formal description and eventually specification would help in such determinations, allowing more objective and precise decisions.

To prevent attacks on the Bitcoin network based on exploiting a flaw in Script, the Bitcoin community agreed on a set of ``standard'' script templates that nodes will process. These limitations, however, are deemed temporary and subject to change in the future [3], although no consensus exists at the moment on what should replace these limitations, if anything. As Bitcoin's economic presence grows, formal specifications, abstracted away from current implementations of the Bitcoin protocol, will become increasingly essential in mediating conflict over what Bitcoin is or should be, allowing participants in the Bitcoin community to reason formally and precisely about their opinions and proposals.

\textcolor{blue}{[anything else? can we add more examples of how a lack of formal specification was problematic?]}


\section{APPROACH}

\subsection{Definition of Script Grammar}
The bulk of our project consists in providing a well-formed and consistent definition of the Script language. This includes a description of the syntax that the text of scripts must conform to, as well descriptions of the operational semantics--big-step and small-step--by which the scripts evaluate. Due to its breadth, we defer the full description of this grammar to [Appendix A].

The reference implementation of Bitcoin defines the network protocol. Script, as the language which expresses and encodes transactions, exists as a subset of the Bitcoin protocol and is therefore also defined by the reference implementation.

In order to generate this grammar, it was ultimately necessary to directly turn to the source code of the reference implementation to validate the correctness of our grammar. Proving the consistency or equivalence of our work with the reference implementation is outside the scope of this project and is left as future work. In the process of forming both our understanding and therefrom

we searched through several reputable sources in order to gain a working understanding of Script, eventually turning to the reference Bitcoin implementation to secure and progressively refine our understanding.

\subsubsection{Syntax}

First, it was necessary to define the syntax. We made heavy use of the [Bitcoin Wiki] to this end. Script is a Forth-like, stack-based language. It is parsed and evaluated left to right [wiki/script]. As it is defined by it's reference implementation, in order to implement the language one must ensure that in all circumstances one's implementation interprets the binary serialization of a script in a manner compatible with the reference.

It was therefore quite natural to define the syntax of the literal bytes that form programs. This is consistent with the internal subdivisions one may discern within a script program. Script defines words or opcodes with defined effects on the state of the program. We look to both the [Bitcoin Wiki] and the source code to retrieve a full list of defined opcodes and to infer and ultimately describe their operations.

The syntax in [Appendix A] defines terms the form of a transaction, with scripts existing within transactions in defined positions. We provide aliases for opcodes' hex values and group commands by both their effect--arithmetic, control, crypto, etc, and their form--whether they are "atomic" or whether the opcode relies on following words or bytes to affect how it transform the state of the program and to give the opcode syntactic validity--the script \texttt{OP\_IF OP\_0 OP\_ELSE} is invalid because it has no \texttt{OP\_ENDIF}.

\subsubsection{Operational semantics}

After providing a sufficient syntax, we moved to describe the operational semantics. We described the big-step semantics and the small-step semantics of the language using a combination of the reference implementation of the language [Ref] and of the Script page of the Bitcoin wiki [Ref].

We provide inference rules for every opcode. The state of the program consists of the stack, $S$, the alt-stack, $AS$, the validity $V$, and the rest of the program to be parsed $P$. Script operates primarily on byte-vectors representing numbers or arbitrary data. We speak of a byte-vector evaluating to a number under a set of encoding rules specific to Bitcoin but not completely described.


A number of op-codes have been disabled due to perceived vulnerabilities, reserved for future use, or reserved for internal use in testing. These are given their own syntactic category and result in an invalid state.

Scripts exist in transactions and op-codes exist which directly reference their transaction context. We omit these because of the disproportionate descriptive burden they introduce.

We also provide small step semantics to describe the progression of evaluation of a script program. The local and global reduction rules are compact due to the language's inherent simplicity.

\subsection{Application of Script Grammar}

[Describe how grammar was used]

\subsection{Difficulties encountered}

$\bullet$ The source code of a script program is just a sequence of bytes and is not human-readable. To make documentation easier, the creators of the language defined an alias (\textit{opcode}) for each command. We first thought that the whole language could be described using only the opcodes, without referring to byte sequences as such, but the very semantics of certain commands made this impossible (see for example the \texttt{OP\_PUSHDATA} commands in Section 2 of the appendix). It took us a few tries to come up with a notation precise enough to describe source code as byte sequences, and yet elegant enough to allow concise expression of the semantics.

$\bullet$ It was our hope that we could define operational semantics for op codes of previous versions of Script that caused crashes or other issues in the past.  Using these definitions, we would then show that the old definitions could be used to cause problems.  Unfortunately, there is very little documentation regarding how these errors came about.  The reference documentation itself only documents changes back to 2014 while most of the serious problems with Script were fixed in 2010. The only fix we were able to analyze was the change to \texttt{OP\_RETURN}.

$\bullet$ \texttt{OP\_CHECKSIG} and related op-codes refer to the serialized form of the surrounding transaction. This is important as the signature which \texttt{OP\_CHECKSIG} verifies serves dually to prove that the author of the transaction is in control of the relevant private key (corresponding to the public key which hashes to the address to which the relevant locked bitcoins were spent) and in fact authored the transaction presently under consideration. Due to the complexities of referencing the serialized form the transaction with big-step semantic inference rules, we did not, after much struggle, provide such rules for such op-codes.

\section{APPLICATIONS AND RESULTS}

In this section, we use our grammar 

\subsection{Programs written in the current version of Script halt within time linear in the length of the program}

\subsubsection{Background}
For the Bitcoin network to function properly, it is important that the network form a single connected component. A type of attack against the network is to try and cut some nodes from the rest of the network, and then ``double-spend'' the same amount of money on the two disconnected components, which will both accept the transactions. Such a cut can be achieved by performing a DoS attack against a group of nodes that collectively ensure connectivity between two otherwise separated subnetworks. One way to perform a DoS attack could be to have a node attempt to evaluate a Script program with an unreasonable execution time. It is therefore important to guarantee that a Script program will terminate within a certain amount of steps.

\subsubsection{Analysis}
Using the small-step semantics defined in Section 3 of the appendix, we see that no reduction rule yields its entire input, as was the case with the \texttt{while} local reduction rule in IMP. That is to say, no recursion is allowed. At most a proper subset of the input is conserved after applying the rule, when it is not completely replaced by \texttt{OP\_NOP}, Script's equivalent of the \texttt{skip} command. This guarantees that every small-step reduction progresses towards termination of the program. Furthermore, the global reduction rule trivially entails that for any program that is not only \texttt{OP\_NOP}, there exists a unique context reducible by a local reduction rule. Thus we have that every Script program halts.

We also know, from our description of Script's big-step semantics in Section 2 of the appendix, that every command requires a constant number of checks and operations on the stack. So we have that a Script program will always halt, and that the number of operations required to evaluate it is at most linear in the amount of commands it contains.

Given that the main nodes on the Bitcoin network enforce a limit on the length of Script programs one can include in a transaction, guaranteed linear execution time results in an absolute maximum number of steps for a standard Script program. This helps in protecting against DoS attacks based on maliciously crafted transactions. Furthermore, this maximum number of steps was deliberately lowered by requiring that the most computationally expensive opcode, \texttt{OP\_CHECKSIG}, be contained exactly once in a valid standard transaction [4].


\subsection{Previous versions of Script allowed skeleton key scripts}

\subsubsection{Background}
The way an amount on Bitcoin is spent on the network is by evaluating to $\sigma[V=valid]$\footnote{See Appendix section 2 for a description of state configurations.} the concatenation $C = BA$ of a locking script A, provided by the payer, and an unlocking script B provided by the recipient. The intended scenario is that $A$ will contain a validation condition, which will check whether the output of $B$ is adequate. Typically, $B$ will have to provide a hash that proves they are the intended recipient of the money spent by the payer, and $A$ will know what to expect as a proof. In that way, $A$ is a guarantee to the payer that the money can only be received by the intended recipient. However, a careless definition of the \texttt{OP\_RETURN} opcode in previous versions of Script made it possible to program skeleton key scripts that could spend any amount of money, without proving the recipient's identity.

\subsubsection{Analysis}
A skeleton script would have the following property: 
$$\exists B. \forall A. \hspace{1.5mm} BA \Downarrow \sigma[V=valid]$$

This is equivalent to saying that either (1) $B$ is such that for any $A$, $BA$ evaluates to a valid state, or (2) $B$ evaluates to a state from which any $A$ will evaluate to a valid state. Case (2) was never possible, since one could write a script $A = \texttt{OP\_0}$, that pushes 0 on the stack. Upon normal program termination, if the top stack value is 0, then the program is deemed invalid. Thus for this $A$ there is no script $B$ such that $BA \Downarrow \sigma[V=valid]$. Case (1), however, was made possible by the semantics of \texttt{OP\_RETURN} prior to July 31 2010. In local reduction rule form, \texttt{OP\_RETURN} was defined as follows:
%
$$<\texttt{OP\_RETURN com}, \sigma> \hspace{3mm} \longrightarrow \hspace{3mm} <\texttt{OP\_NOP}, \sigma>$$
%
Evaluating \texttt{OP\_RETURN} results in the immediate termination of the program, \textit{without any changes to the state}. Consider now a script $B = \texttt{OP\_1 OP\_RETURN}$, and the evaluation of $BA$ for any arbitrary script $A$:

\begin{enumerate}
  \item \texttt{1} is pushed onto the stack
  \item \texttt{OP\_RETURN} triggers program termination
  \item The top stack value is nonzero, and so the program is deemed valid
\end{enumerate}

Clearly, that such a script was possible completely defeated the transaction validation process. \texttt{OP\_RETURN} semantics were subsequently changed to the following:
%
$$<\texttt{OP\_RETURN com}, \sigma> \hspace{1mm} \longrightarrow \hspace{1mm} <\texttt{OP\_NOP}, \sigma[V=invalid]>$$
%
thus ensuring that its evaluation in a script invariably resulted in a rejected transaction.
As no other command in the language can cause early termination of the program with a valid state, we can now say that there exists no skeleton key script that could serve to unlock any arbitrary locking script.

\section{RELATED WORK}

To our knowledge, there has been no previous effort to provide a formal specification of the Script language. As a result, the existing documentation works as a rough guideline for our work but is not complete. Explanations of how Script works are located on the Bitcoin wiki [2] and the reference implementation [1].  

The Bitcoin wiki is an explanation of how each opcode works in plain English. The explanations are not rigorous, and are not in a logical formalism that allows mathematical reasoning. There are many situations where descriptions are vague and can be interpreted in more than one way.  For example, the explanation of \texttt{OP\_LEFT} takes an argument to index a string and throws away everything to the right of the index, but it does not specify whether that operation is right-inclusive.

The reference implementation is much more thorough that the wiki but, being C++ code, it is much harder to interpret and is not in a format that allows for logical reasoning. If we turn to Forth to find something related, we can find standard specifications like the Forth-83 standard (http://forth.sourceforge.net/standard/fst83/fst83-12.htm). However even these specifications are given in plain English.


\section{CONCLUSIONS}

\addtolength{\textheight}{-12cm}   % This command serves to balance the column lengths
                                  % on the last page of the document manually. It shortens
                                  % the textheight of the last page by a suitable amount.
                                  % This command does not take effect until the next page
                                  % so it should come on the page before the last. Make
                                  % sure that you do not shorten the textheight too much.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{thebibliography}{99}
\bibitem{c1} Bitcoin Core. (March 2017). \textit{Bitcoin Core} [Online; Accessed: 15-March-2017]. Available: https://github.com/bitcoin/bitcoin.

\bibitem{c2} Bitcoin Wiki. (March 2017). \textit{Script} [Online; Accessed: 15-March-2017]. Available: https://en.bitcoin.it/wiki/Script.

\bibitem{c3} Andreas M. Antonopoulos. (October 18 2016). \textit{Mastering Bitcoin - Unlocking digital currencies} [Online; Accessed: 15-March-2017]. Available: https://github.com/bitcoinbook/bitcoinbook.

\bibitem{c4} CVE Details. (March 3 2012). \textit{Vulnerability Details : CVE-2013-2292} [Online; Accessed: 15-March-2017]. Available: https://www.cvedetails.com/cve-details.php?t=1\&cve\_id=CVE-2013-2292.

\end{thebibliography}




\end{document}
